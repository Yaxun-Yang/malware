import numpy as np
import pandas as pd
import tensorflow as tf
from sklearn.manifold import TSNE
from sklearn import preprocessing
import matplotlib.pyplot as plt


def data_read():
    data = pd.read_json("~/opcode2vec/base_data/opcode_uuid_md5.json", orient='index')
    # data = pd.read_json("base_data/opcode_uuid_md5.json", orient='index')
    return data.to_numpy()


def data_write(train_x, train_y, op_size):
    df = pd.DataFrame(train_x)
    df.to_csv("~/opcode2vec/processed_data/train_x_{}.csv".format(op_size), mode='w', sep=',', index=False)
    # df.to_csv("processed_data/train_x_{}.csv".format(op_size), mode='w', sep=',', index=False)
    df2 = pd.DataFrame(train_y)
    df2.to_csv("~/opcode2vec/processed_data/train_y_{}.csv".format(op_size), mode='w', sep=',', index=False)
    # df2.to_csv("processed_data/train_y_{}.csv".format(op_size), mode='w', sep=',', index=False)


def to_one_hot(index, op_size):
    temp = np.zeros(op_size)
    temp[index] = 1
    return temp


def get_train_set(data):

    opcodes = []
    # *****
    for i, web_shell in enumerate(data):
        print("builded:", i)
        for opcode in web_shell:
            if opcode is None:
                break
            else:
                if opcode[0] not in opcodes:
                    opcodes.append(opcode[0])
                if opcode[1] not in opcodes:
                    opcodes.append(opcode[1])

    opcode2int = {}
    int2opcode = {}

    op_size = len(opcodes)
    # print(op_size)

    for i, opcode in enumerate(opcodes):
        # print(opcode, i)
        opcode2int[opcode] = i
        int2opcode[i] = opcode

    # *****

    with open("~/opcode2vec/processed_data/train_x_{}.csv".format(op_size), 'w') as file_x:
    # with open("processed_data/train_x_{}.csv".format(op_size), 'w') as file_x:
        with open("~/opcode2vec/processed_data/train_y_{}.csv".format(op_size), 'w') as file_y:
        # with open("processed_data/train_y_{}.csv".format(op_size), 'w') as file_y:
            for i, web_shell in enumerate(data):
                print("transed:", i)
                for opcode in web_shell:
                    if opcode is None:
                        break
                    else:
                        file_x.write(str(to_one_hot(opcode2int[opcode[0]], op_size)) + '\n')
                        file_y.write(str(to_one_hot(opcode2int[opcode[1]], op_size)) + '\n')

    return opcodes, opcode2int, op_size


def train(op_size):
    train_x = pd.read_csv("~/opcode2vec/processed_data/train_x_{}.csv".format(op_size), header=None)
    train_y = pd.read_csv("~/opcode2vec/processed_data/train_y_{}.csv".format(op_size), header=None)
    # train_x = pd.read_csv("processed_data/train_x_{}.csv".format(op_size), header=None)
    # train_y = pd.read_csv("processed_data/train_y_{}.csv".format(op_size), header=None)
    # *****
    dim = 100
    optimizer = tf.optimizers.Adam()

    w1 = tf.Variable(tf.random.normal([op_size, dim]))
    b1 = tf.Variable(tf.random.normal([[dim]]))

    w2 = tf.Variable(tf.random.normal([dim, op_size]))
    b2 = tf.Variable(tf.random.normal([op_size]))

    for _ in range(100):
        with tf.GradientTape() as t:
            hidden_layer = tf.add(tf.matmul(train_x, w1), b1)
            output_layer = tf.nn.softmax(tf.add(tf.matmul(hidden_layer, w2), b2))
            cross_entropy_loss = tf.reduce_mean(- tf.math.reduce_sum(train_y * tf.math.log(output_layer)), axis=[1])

            grads = t.gradient(cross_entropy_loss, [w1, b1, w2, b2])
            optimizer.apply_gradients(zip(grads, [w1, b1, w2, b2]))
        if _ % 10 == 0:
            print("iter ", _, " loss: ", cross_entropy_loss)

    return w1, b1


def twod_space(vectors, opcodes, opcode2int):
    model = TSNE(n_components=2, random_state=0)
    np.set_printoptions(suppress=True)
    vectors = model.fit_transform(vectors)
    normalizer = preprocessing.Normalizer()
    vectors = normalizer.fit_transform(vectors, '12')

    fig, ax = plt.subplots()
    ax.set_xlim(left=-1, right=1)
    ax.set_ylim(bottom=-1, top=1)
    for opcode in opcodes:
        print(opcode, vectors[opcode2int[opcode]][1], vectors[opcode2int[opcode]][1])
        ax.annotate(opcode, (vectors[opcode2int[opcode]][0], vectors[opcode2int[opcode]][1]))

    plt.savefig("~/opcode2vec/processed_data/2_dim_fig.png")
    # plt.savefig("processed_data/2_dim_fig.png")
    # plt.show()


def main():
    data = data_read()
    opcodes, opcode2int, op_size = get_train_set(data)
    # data_write(train_x, train_y, op_size)
    w, b = train(op_size)
    vectors = w + b
    twod_space(vectors, opcodes, opcode2int)


if __name__ == '__main__':
    main()
